![Python](https://img.shields.io/badge/python-3.10%2B-blue)
![License](https://img.shields.io/github/license/Petyall/FastAPI-AuthHub)
![Framework](https://img.shields.io/badge/FastAPI-0.115.12-green)


# Пример API с JWT-авторизацией, ролевой моделью и подтверждением регистрации по email, написанным на FastAPI

Современное, безопасное и масштабируемое API с ролевой системой, JWT-авторизацией, многоуровневой валидацией паролей, подтверждением email, восстановлением пароля и защитой от перегрузок. API спроектировано для удобства разработки, поддержки и расширения функционала.

## Основные особенности и преимущества

### 1. **Безопасная система аутентификации**
- **JWT-авторизация**. Использует access и refresh-токены с асимметричным RSA-шифрованием для надежной защиты пользовательских сессий.
- **Управление refresh-токенами**. Токены хранятся в базе данных с автоматическим отзывом при выходе, обновлении или сбросе пароля, обеспечивая контроль сессий.
- **Безопасность паролей**. Хеширование паролей с помощью bcrypt и настраиваемая валидация (уровни: none, light, medium, strong) для защиты от слабых паролей.
- **Документированные эндпоинты**. Каждый эндпоинт сопровождается докстрингами с описанием параметров, возвращаемых значений и возможных исключений.
- **Cookies**. Токены хранятся в HTTP-only, secure cookies с SameSite="Lax" для защиты от XSS и CSRF-атак.

### 2. **Гибкое управление пользователями**
- **Ролевой доступ (RBAC)**. Поддержка ролей (USER, ADMIN) с возможностью легкого добавления новых ролей через таблицу `roles`.
- **Профили пользователей**. Хранение email, имени, телефона, даты рождения, времени регистрации и последней активности.
- **Функции безопасности**:
  - Подтверждение email с использованием уникальных токенов.
  - Сброс пароля через защищенные токены с ограниченным сроком действия.
  - Блокировка/разблокировка учетной записи с фиксацией времени бана.

### 3. **Интеграция с email**
- **Асинхронная отправка писем**. Использование `aiosmtplib` с повторными попытками при сетевых сбоях для надежной доставки.
- **Шаблоны писем**. HTML-шаблоны через Jinja2 для писем подтверждения и сброса пароля, легко настраиваемые для кастомизации.
- **Гибкие SMTP-настройки**. Поддержка любого SMTP-сервера через конфигурацию в `.env`.

### 4. **Надежная интеграция с базой данных**
- **SQLAlchemy ORM**. Асинхронный и типобезопасный интерфейс для работы с базой данных, минимизирующий ошибки.
- **Поддержка разных СУБД**. Совместимость с PostgreSQL и SQLite, настраиваемая через `.env`.
- **Шаблон репозитория**. Универсальный класс `BaseRepository` для CRUD-операций, упрощающий добавление новых моделей.

### 5. **Ограничение запросов и безопасность**
- **Rate Limiting**. Использование `slowapi` для ограничения частоты запросов на эндпоинтах (например, регистрация: 2 раза в минуту, вход 5 раз в минуту).
- **Обработка ошибок**. Централизованная обработка исключений с логированием серверных ошибок и понятными сообщениями для клиента.
- **Валидация данных**. Pydantic для строгой проверки входных данных и автоматической генерации OpenAPI-документации.

### 6. **Удобство для разработчиков**
- **Модульная архитектура**. Код разделен на модули (`auth`, `email`, `users`), что упрощает расширение и поддержку.
- **Логирование**. Подробные логи ошибок и событий в консоль и файл для удобной отладки.
- **Конфигурация через .env**. Все настройки (база данных, JWT, SMTP) задаются через Pydantic `BaseSettings` для гибкости в разных окружениях.
- **Читаемый код**. Строгая типизация, докстринги и логичная структура функций/классов для быстрого понимания.
- **Масштабируемость**. Легкое добавление новых ролей, эндпоинтов и моделей через наследование `BaseRepository` и подключение `APIRouter`.

## Структура проекта

```plaintext
├── alembic/                    # Миграции базы данных
├── src/
│   ├── auth/
│   │   ├── schemas/            # Pydantic-модели для запросов и ответов
│   │   ├── utils/              # Утилиты для JWT, паролей, cookies
│   │   ├── constants.py        # Определение ролей
│   │   ├── dependencies.py     # Зависимости FastAPI для аутентификации
│   │   ├── router.py           # Эндпоинты аутентификации
│   │   ├── services.py         # Бизнес-логика для пользователей и токенов
│   ├── email/
│   │   ├── schemas/            # Pydantic-модели для email
│   │   ├── utils/              # Утилиты для отправки писем и рендеринга шаблонов
│   │   ├── router.py           # Эндпоинты для работы с email
│   ├── users/
│   │   ├── schemas/            # Pydantic-модели для users
│   │   ├── router.py           # Эндпоинты для работы с users
│   ├── limits/
│   │   ├── limiter.py          # Настройка ограничения запросов
│   ├── logs/
│   │   ├── logger.py           # Конфигурация логирования
│   ├── config.py               # Настройки приложения
│   ├── database.py             # Настройка SQLAlchemy
│   ├── exceptions.py           # Пользовательские исключения
│   ├── main.py                 # Точка входа FastAPI
│   ├── models.py               # Модели SQLAlchemy
│   ├── services.py             # Универсальный шаблон репозитория
│   ├── rsa_keygen.py           # Генератор открытого и закрытого ключей для RSA-шифрования
├── .env-example                # Пример .env файла
├── alembic.ini                 # Конфигурация Alembic
├── private.pem-example         # Пример приватного ключа
├── public.pem-example          # Пример публичного ключа
├── requirements.txt            # Зависимости проекта
```

## Установка

1. **Клонирование репозитория**.
   ```bash
   git clone https://github.com/Petyall/FastAPI-AuthHub.git
   cd FastAPI-AuthHub
   ```

2. **Создание виртуального окружения**.
   ```bash
   python -m venv venv
   source venv/bin/activate  # Для Windows: venv\Scripts\activate
   ```

3. **Установка зависимостей**.
   ```bash
   pip install -r requirements.txt
   ```

4. **Настройка переменных окружения**.
   Создайте файл `.env` в корне проекта на основе `.env-example`. Пример:
   ```env
   DB_TYPE=postgresql
   DB_HOST=localhost
   DB_PORT=5432
   DB_USER=your_user
   DB_PASS=your_password
   DB_NAME=your_database
   JWT_PRIVATE_KEY_PATH=private.pem
   JWT_PUBLIC_KEY_PATH=public.pem
   SMTP_HOST=smtp.example.com
   SMTP_PORT=587
   SMTP_USERNAME=your_smtp_user
   SMTP_PASSWORD=your_smtp_password
   EMAIL_FROM=no-reply@example.com
   FRONTEND_URL=http://localhost:3000
   ENABLE_RATE_LIMITER=True
   ```

5. **Применение миграций базы данных**:
   ```bash
   alembic upgrade head
   ```

6. **Запуск приложения**.
   ```bash
   fastapi dev src/main.py
   ```

6. **Проверка работоспособности**.
   ```bash
   http://localhost:8000/docs
   ```

## Эндпоинты API

Ниже приведены основные эндпоинты API с примерами запросов и ответов. Все эндпоинты используют JSON и возвращают структурированные ответы с помощью Pydantic-схем. Некоторые эндпоинты ограничены по частоте запросов (`slowapi`).

### Аутентификация

#### POST /auth/register
Регистрирует нового пользователя. Если включено подтверждение email (`ENABLE_EMAIL_CONFIRMATION=True`), отправляет письмо с токеном.

- **Ограничение**: 2 запроса в минуту.
- **Тело запроса**:
  ```json
  {
    "email": "user@example.com",
    "password": "StrongPass123!",
    "first_name": "John",
    "last_name": "Doe",
    "paternal_name": null,
    "phone_number": "+1234567890",
    "birthday": "1990-01-01"
  }
  ```
- **Успешный ответ (200)**:
  ```json
  {
    "message": "Пользователь 'user@example.com' создан успешно. В течение 24 часов вам придет сообщение на почту для подтверждения регистрации."
  }
  ```
- **Ошибка (409, пользователь существует)**:
  ```json
  {
    "error": "Пользователь user@example.com уже зарегистрирован"
  }
  ```

#### POST /auth/login
Аутентифицирует пользователя, устанавливает JWT-токены в cookies.

- **Ограничение**: 5 запросов в минуту.
- **Тело запроса**:
  ```json
  {
    "email": "user@example.com",
    "password": "StrongPass123!"
  }
  ```
- **Успешный ответ (200)**:
  ```json
  {
    "message": "Успешный вход",
    "user": "user@example.com"
  }
  ```
  *Cookies*: `access_token`, `refresh_token` (HTTP-only, secure).
- **Ошибка (401, неверные данные)**:
  ```json
  {
    "error": "Неверные учётные данные"
  }
  ```

#### POST /auth/logout
Выполняет выход, отзывает refresh-токен и удаляет cookies.

- **Требуется**: `refresh_token` в cookies.
- **Успешный ответ (200)**:
  ```json
  {
    "message": "Выход выполнен"
  }
  ```
- **Ошибка (401, токен отсутствует)**:
  ```json
  {
    "error": "Токен обновления не предоставлен"
  }
  ```

#### POST /auth/refresh
Обновляет access и refresh-токены.

- **Ограничение**: 10 запросов в минуту.
- **Требуется**: `refresh_token` в cookies.
- **Успешный ответ (200)**:
  ```json
  {
    "message": "Токены обновлены",
    "user": "user@example.com"
  }
  ```
  *Cookies*: Новые `access_token`, `refresh_token`.
- **Ошибка (401, недействительный токен)**:
  ```json
  {
    "error": "Недействительный токен обновления"
  }
  ```

#### POST /auth/forgot-password
Инициирует сброс пароля, отправляет письмо с токеном.

- **Ограничение**: 2 запроса в минуту.
- **Тело запроса**:
  ```json
  {
    "email": "user@example.com"
  }
  ```
- **Успешный ответ (200)**:
  ```json
  {
    "message": "Если пользователь существует, на его email отправлено письмо с инструкцией по сбросу пароля"
  }
  ```

#### POST /auth/reset-password
Сбрасывает пароль по токену.

- **Ограничение**: 5 запросов в минуту.
- **Тело запроса**:
  ```json
  {
    "token": "reset_token_here",
    "new_password": "NewPass123!"
  }
  ```
- **Успешный ответ (200)**:
  ```json
  {
    "message": "Пароль успешно изменён"
  }
  ```
- **Ошибка (400, недействительный токен)**:
  ```json
  {
    "error": "Ссылка для сброса пароля недействительна"
  }
  ```

#### PATCH /auth/ban
Блокирует пользователя (только для администраторов).

- **Требуется**: `access_token` с ролью ADMIN.
- **Тело запроса**:
  ```json
  {
    "email": "user@example.com"
  }
  ```
- **Успешный ответ (200)**:
  ```json
  {
    "id": 1,
    "email": "user@example.com",
    "ban_date": "2025-06-24T15:02:00"
  }
  ```
- **Ошибка (409, попытка забанить себя)**:
  ```json
  {
    "error": "Вы не можете заблокировать сами себя"
  }
  ```

#### PATCH /auth/unban
Разблокирует пользователя (только для администраторов).

- **Требуется**: `access_token` с ролью ADMIN.
- **Тело запроса**:
  ```json
  {
    "email": "user@example.com"
  }
  ```
- **Успешный ответ (200)**:
  ```json
  {
    "id": 1,
    "email": "user@example.com",
    "ban_date": null
  }
  ```
- **Ошибка (409, пользователь не заблокирован)**:
  ```json
  {
    "error": "У пользователя user@example.com нет блокировки"
  }
  ```

### Email

#### POST /email/confirm
Подтверждает email по токену.

- **Ограничение**: 5 запросов в минуту.
- **Тело запроса**:
  ```json
  {
    "email": "user@example.com",
    "confirmation_token": "token_here"
  }
  ```
- **Успешный ответ (200)**:
  ```json
  {
    "message": "Email успешно подтверждён"
  }
  ```
- **Ошибка (400, недействительный токен)**:
  ```json
  {
    "error": "Ссылка подтверждения недействительна или устарела"
  }
  ```

#### POST /email/resend
Повторно отправляет письмо подтверждения.

- **Ограничение**: 2 запроса в минуту.
- **Требуется**: `access_token`.
- **Успешный ответ (200)**:
  ```json
  {
    "message": "Если аккаунт существует, письмо отправлено повторно"
  }
  ```
- **Ошибка (429, слишком частая отправка)**:
  ```json
  {
    "error": "Слишком частые попытки. Попробуйте позже"
  }
  ```

### Пользователи

#### GET /users/me
Возвращает профиль текущего пользователя.

- **Требуется**: `access_token`.
- **Успешный ответ (200)**:
  ```json
  {
    "id": 1,
    "email": "user@example.com",
    "first_name": "John",
    "last_name": "Doe"
  }
  ```
- **Ошибка (401, токен недействителен)**:
  ```json
  {
    "error": "Недействительный токен доступа"
  }
  ```

#### GET /users/all
Возвращает список всех пользователей (только для администраторов).

- **Требуется**: `access_token` с ролью ADMIN.
- **Успешный ответ (200)**:
  ```json
  {
    "users": [
      {
        "id": 1,
        "email": "user@example.com",
        "ban_date": null
      }
    ]
  }
  ```
- **Ошибка (403, недостаточно прав)**:
  ```json
  {
    "error": "Доступ запрещён"
  }
  ```

#### POST /users/find-by-email
Находит пользователя по email (только для администраторов).

- **Требуется**: `access_token` с ролью ADMIN.
- **Тело запроса**:
  ```json
  {
    "email": "user@example.com"
  }
  ```
- **Успешный ответ (200)**:
  ```json
  {
    "id": 1,
    "email": "user@example.com",
    "ban_date": null
  }
  ```
- **Ошибка (404, пользователь не найден)**:
  ```json
  {
    "error": "Пользователь user@example.com не найден"
  }
  ```

## Требования

- Python 3.10+
- PostgreSQL или SQLite
- SMTP-сервер для отправки писем
- Зависимости из `requirements.txt`

## Миграции базы данных

Проект использует Alembic для управления схемой базы данных. Для создания новой миграции:
```bash
alembic revision --autogenerate -m "Описание миграции"
```
Для применения миграций:
```bash
alembic upgrade head
```